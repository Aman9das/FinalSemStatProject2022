---
title: End-Semester Project
subtitle: Bivariate Analysis on GDP per capita, Sanitation and Life Expectancy across Nations in 2010
author:
  - Aman Das [BS2206]
  - Raj Pratap Singh [BS2219]
  - Shreyansh Mukhopadhyay [BS2147]
format:
  revealjs:
    width: 1200
    height: 750
    output-file: PPT_Reveal.html
    embed-resources: true
    theme: [default, custom.scss]
    highlight-style: gruvbox
    transition: slide
    toc: true
    toc-depth: 1
    hide-inactive-cursor: true
    code-fold: true
    menu: false
    scrollable: true
    history: true
    preview-links: true
    controls: true
  html:
    output-file: DOC_html.html
    embed-resources: true
    toc: true
    html-math-method: katex
    highlight-style: gruvbox-dark
    theme:
      light: sandstone
      dark: slate
  pptx:
    output-file: PPT_powerpoint.pptx
    reference-doc: ./Templates/template1.pptx
  pdf:
    documentclass: article
    margin-left: 40pt
    margin-right: 80pt
    echo: false
    output-file: DOC_pdf.pdf
    toc: true
    number-sections: true
    code-fold: true
execute:
  cache: false
---

```{r include=FALSE}
library(knitr)
library(ggplot2)
library(quantreg)
library(ppcor)
library(psych)
library(moments)
library(latex2exp)
library(maps)

require(data.table)

mytheme=theme_minimal()+
theme(
  plot.background = element_rect(fill = "#f9f5d7", color = NA),
  panel.grid = element_line(colour = "#d5c4a1"),
  axis.line = element_line(colour = "#928374"),
  )
mycolor=scale_color_manual(
      values=c(
        "#cc241d80",
        "#45858880",
        "#d65d0e80",
        "#689d6a80"
        ),
      aesthetics=c(
        "fill",
        "colour"
      )
      )
```

# Introduction

## Overview {.smaller}

Sanitation of oneself is one of the basic duties of a human being. We know poor sanitation is linked to transmission of diarrhoeal diseases such as cholera and dysentery, as well as typhoid, intestinal worm infections and polio which directly affect the health of an individual.

Also know that the Gross Domestic Product per capita of a country basically tells about the wealth of a country. So, in this project Our *Aim* is to determine how these features affect the *Health* of the citizens. We use *Life Expectation* as a measurable proxy for health.

::: notes
Everybody is taught to keep a good hygiene since childhood. Because poor sanitation can be the cause for various diseases. Sanitation has therefore become an important part of life for most of us. However, even in today's times there are countries where sanitation is not considered important.

The GDP per capita tells us about how people live, and thus it can tell us about the health of the people also.

In this project we aim to conduct a data analysis on how these factors affect the life expectancy.
:::

```{r message=FALSE, warning=FALSE}
#| fig-align: center

numerise = function(x){
  x[grepl("k$", x)] <- as.numeric(sub("k$", "", x[grepl("k$", x)]))*10^3
  x <- as.numeric(x)
  return(x)
}

yearname = "X2000"

d3_raw = read.csv(file.path(".","Data","life_expectancy.csv"), fileEncoding = 'UTF-8-BOM')
d3 = d3_raw[!is.na(numerise(d3_raw[, yearname])),][,c("country", yearname)]
colnames(d3)[2] = "lfx"

world=map_data("world")

w3<-data.frame(world,data=sample(10,length(unique(world$group)),T)[world$group])

d3[d3 == "United States"] = "USA"
d3[d3 == "Congo, Dem. Rep."] = "Democratic Republic of the Congo"
d3[d3 == "Congo, Rep."] = "Republic of Congo"
d3[d3 == "Kyrgyz Republic"] = "Kyrgyzstan"
d3[d3 == "Cote d'Ivoire"] = "Ivory Coast"
d3[d3 == "United Kingdom"] = "UK"

dt_d3 = as.data.table(d3)
setkey(dt_d3, country)
dt_w = as.data.table(world)
setkey(dt_w, region)

new_w = as.data.frame(dt_w[dt_d3])

ggplot(new_w,aes(long,lat,group=group,fill=lfx))+
    geom_polygon(color="#282828", linewidth=rel(0.5))+
    scale_fill_gradient(low="#fabd2f",high="#cc241d")+
    mytheme+
  theme(
    axis.text=element_blank(),
    axis.title = element_blank(),
    axis.line=element_blank()
  )+
  labs(fill="Linear Model")
```

## Data Points

This presentation demonstrates the capabilities of *Bivariate Analysis* on data-sets, to infer relationship between various features of Nations. The co-variates taken in consideration are as follows:

-   **log of GDP per capita**: Logarithm ( base $e$) of Gross Domestic Product (in \$) per citizen, adjusted for Inflation. \[*lngdp*\]
-   **Sanitation Access %**: Percentage of people using at least basic Sanitation facilities, not shared with other households. \[*snt*\]
-   **Life Expectancy**: The average number of years a newly born child would live, provided current mortality patterns hold. \[*lfx*\]

## Data

```{r echo=TRUE, collapse=TRUE}
script.dir <- getSrcDirectory(function(x) {x})
setwd(script.dir)

numerise = function(x){
  x[grepl("k$", x)] <- as.numeric(sub("k$", "", x[grepl("k$", x)]))*10^3
  x <- as.numeric(x)
  return(x)
}

d1_raw = read.csv(file.path(".","Data","gdp.csv"), fileEncoding = 'UTF-8-BOM')
d2_raw = read.csv(file.path(".","Data","sanitation.csv"), fileEncoding = 'UTF-8-BOM')
d3_raw = read.csv(file.path(".","Data","life_expectancy.csv"), fileEncoding = 'UTF-8-BOM')

yearname = "X2010"

d1 = d1_raw[!is.na(numerise(d1_raw[, yearname])),][,c("country", yearname)]
colnames(d1)[2] = "lngdp"
d2 = d2_raw[!is.na(numerise(d2_raw[, yearname])),][,c("country", yearname)]
colnames(d2)[2] = "snt"
d3 = d3_raw[!is.na(numerise(d3_raw[, yearname])),][,c("country", yearname)]
colnames(d3)[2] = "lfx"

dtemp = merge(x = d1, y = d2, by = "country")
d = merge(x = dtemp, y = d3, by = "country")

d$lngdp = log(numerise(d$lngdp))

write.csv(d, "./Data/assembled.csv")

kable(head(d, 6L))
```

::: aside
<sub>FREE DATA FROM [UN](un.org), [WORLD BANK](https://worldbank.org), [WHO](https://who.org), [IMHE](http://www.healthdata.org/) VIA [GAPMINDER.ORG](https://gapminder.org), [CC-BY LICENSE](https://creativecommons.org/licenses/by/2.0/).</sub>
:::

# Elementary Univariate Analysis

## Measures of Central Tendency {.smaller}

*Mean or Arithmetic Mean* $\bar{x}$, *Geometric Mean* $\operatorname{GM}(x)$, *Harmonic Mean* $\operatorname{HM}(x)$, *Median* $\operatorname{median}(x)$ and *Mode* $\operatorname{mode}(x)$ are some measures of *central tendency* in the sample.

<details>

<summary>Formulae</summary>

$$
\begin{aligned}
\operatorname{mean}(x)=\bar{x} = \frac{1}{n} \sum _{i=1}^{n}(x_{i}) &&
\operatorname{GM}(x) = \sqrt[n]{\prod_{i=1}^n} x_i
\end{aligned}
$$ $$
\operatorname{HM}(x)= n\sum_{i=1}^n x_i^{-1}
$$ $$
\begin{aligned}
\operatorname{median}(x)=\begin{cases}
x_{(n + 1)/ 2} &: n = 1 \mod{2} \\
\frac{x_{(n/2)} + x_{((n/2)+1)}}{2} &:n = 0 \mod{2}
\end{cases} &&
\operatorname{mode}(x) = x_{(n)}
\end{aligned}
$$

Note: $x_i$ is the i<sup>th</sup> observation. $x_{(i)}$ is the i<sup>th</sup> largest observation.

</details>

```{r echo=TRUE}
getmode <- function(v) {
 uniqv <- unique(v)
 freq = max(tabulate(match(v, uniqv)))
 res = uniqv[which.max(tabulate(match(v, uniqv)))]
 if (freq == 1) res = NULL
 return(res)
}

d_central = data.frame(
  row.names = "Variable",
  Variable = c(
    "*ln(GDP)*",
    "*Sanitation*",
    "*Life Exp.*"
  ),
  Mean = c(
    mean(d$lngdp),
    mean(d$snt),
    mean(d$lfx)
  ),
  GM = c(
    geometric.mean(d$lngdp),
    geometric.mean(d$snt),
    geometric.mean(d$lfx)
  ),
  HM = c(
    harmonic.mean(d$lngdp),
    harmonic.mean(d$snt),
    harmonic.mean(d$lfx)
  ),
  Median = c(
    median(d$lngdp),
    median(d$snt),
    median(d$lfx)
  ),
  Mode = c(
    getmode(d$lngdp),
    getmode(d$snt),
    getmode(d$lfx)
  )
)

kable(
  d_central,
  col.names = c(
    "$\\bar{x}$",
    "$\\operatorname{GM}(x)$",
    "$\\operatorname{HM}(x)$",
    "$\\operatorname{median}(x)$",
    "$\\operatorname{mode}(x)$"
  ),
  digits=5
)
```

## Measures of Dispersion {.smaller}

*Range* $\operatorname{range}(x)$, *Semi-Interquartile Range* $\operatorname{SIR}(x)$, *Mean Deviation about x'* $\operatorname{MD}_{(x')}(x)$, *Variance* $s_x^2$, *Standard Deviation* $s_x$ are some measures of *dispersion* in the sample.

<details>

<summary>Formulae</summary>

$$
\begin{aligned}
\operatorname{Range}(x)=|x_{(n)} - x_{(1)}| &&
\ Q_1 = \operatorname{median}(x_{(1)}, \ldots ,x_{(\lfloor \frac{n+1}{2} \rfloor)}) &&
\end{aligned}
$$ $$
\begin{aligned}
\ Q_3 = \operatorname{median}(x_{(\lfloor \frac{n+2}{2} \rfloor)}, \ldots , x_{(n)}) &&
\operatorname{MD}_{(x')}(x) = \operatorname{mean}(|x_i-x'|)
\end{aligned}
$$ $$
\begin{aligned}
\operatorname{SIR}(x)=\frac{|Q_1-Q_3|}{2} &&
s_x = \sqrt{\operatorname{mean}([x_i - \bar{x}]^2)} &&
s^2_x= (s_x)^2
\end{aligned}
$$

</details>

```{r echo=TRUE}
getmd = function(x, center = mean(x)){
  md = mean(
    abs(
      x - rep(center, length(x))
      )
    )
  return(md)
}
d_disp = data.frame(
  row.names = "Variable",
  Variable = c(
    "*ln(GDP)*",
    "*Sanitation*",
    "*Life Exp.*"
  ),
  Range = c(
    max(d$lngdp) - min(d$lngdp),
    max(d$snt) - min(d$snt),
    max(d$lfx) - min(d$lfx)
  ),
  SIR = c(
    IQR(d$lngdp)/2,
    IQR(d$snt)/2,
    IQR(d$lfx)/2
  ),
  MD = c(
    getmd(d$lngdp),
    getmd(d$snt),
    getmd(d$lfx)
  ),
  variance = c(
    (sd(d$lngdp))^2,
    (sd(d$snt))^2,
    (sd(d$lfx))^2
  ),
  SD = c(
    sd(d$lngdp),
    sd(d$snt),
    sd(d$lfx)
  )
)

kable(
  d_disp,
  col.names = c(
    "$\\operatorname{Range}(x)$",
    "$\\operatorname{SIR}(x)$",
    "$\\operatorname{MD}_{(\\bar{x})}(x)$",
    "$\\quad \\quad \\quad \\quad s_x^2$",
    "$\\quad \\quad \\quad \\quad s_x$"
  ),
  digits=5
)
```

## Measures of Shape

Coefficients of *Skewness* $g_1$ and *Kurtosis* $g_2$ describe the symmetry and extremity of tails of the sample distribution.

<details>

<summary>Formulae</summary>

$$
\begin{aligned}
m_k = \operatorname{mean}([x-\bar{x}]^k) &&
g_1 = \frac{m_3}{{m_2}^{\frac{3}{2}}} &&
g_2 = \frac{m_4}{{m_2}^2}
\end{aligned}
$$

</details>

```{r echo=TRUE}
d_shape = data.frame(
  row.names = "Variable",
  Variable = c(
    "*ln(GDP)*",
    "*Sanitation*",
    "*Life Exp.*"
  ),
  Skewness = c(
    skewness(d$lngdp),
    skewness(d$snt),
    skewness(d$lfx)
  ),
  Kurtosis = c(
    kurtosis(d$lngdp),
    kurtosis(d$snt),
    kurtosis(d$lfx)
  )
)

kable(
  d_shape,
  col.names = c(
    "$g_1$",
    "$g_2$"
  ),
  digits=5
)
```

## Density Plot {.smaller}

*Density plots* help us in estimating the form, location and spread of the distribution.

```{r echo=TRUE}
#| fig-align: center
labelfunction = function(val1){
  return(list(c(
    "log of GDP per capita",
    "Sanitation Access %",
    "Life Expectancy"
  )))
}
ggplot(stack(d[2:4]), mapping = aes(x = values))+
geom_density(aes(color=ind), linewidth=rel(1.5))+
labs(
  x=NULL,
  y=NULL
  )+
mytheme+
mycolor+
facet_wrap(~ind, scales="free", labeller = labelfunction, ncol=1)+
  theme(legend.position="none",
        strip.text.x = element_text(size = rel(1.5))
  )
```

## Box Plot {.smaller scrollable="false"}

*Box plots* help us detect potential outliers. They also help us in estimating location and skewness of the distribution.

```{r echo=TRUE}
#| fig-align: center
labelfunction = function(val1){
  return(list(c(
    "log of GDP per capita",
    "Sanitation Access %",
    "Life Expectancy"
  )))
}
ggplot(stack(d[2:4]), mapping = aes(y = values))+
geom_boxplot(aes(fill=ind), alpha=0.6)+
labs(
  x=NULL,
  y=NULL
  )+
mytheme+
mycolor+
facet_wrap(~ind, scales="free", labeller = labelfunction)+
  theme(axis.text.x=element_blank(),
        legend.position="none",
        strip.text.x = element_text(size = rel(1.5)),
        panel.grid.minor.x = element_blank(),
        panel.grid.major.x = element_blank()
  )
```

## Inferences

From the density plots, we can infer the following:

The density of the log of GDP per capita is symmetric as supported by the fact that the skewness was close to 0.

The other two density plots appear left skewed as supported by negative skewness.

From the box plots we can infer the following:

The median seems to be in

# Scatter Plot

A *Scatter plot* helps us estimate the type of relationship between variables.

```{r echo=TRUE}
sctrplot = function(
    d, x_map, y_map,
    x_lab=waiver(), y_lab=waiver(),
    title=waiver()
){
  plot1 = ggplot(d, mapping = aes(x = x_map, y = y_map))+
    geom_point(
      alpha=0.6
    )+
    mytheme+
    labs(
      x=x_lab,
      y=y_lab,
      title=title
    )
  
  return(plot1)
}
```

## Sanitation vs. GDP per Capita

```{r}
sctrplot(d, d$lngdp, d$snt, "log of GDP per capita", "Sanitation Access %")
```

## Life Expectancy vs. GDP per Capita

```{r}
sctrplot(d, d$lngdp, d$lfx, "log of GDP per capita", "Life Expectancy")
```

## Life Expectation vs. Sanitation

```{r}
sctrplot(d, d$snt, d$lfx, "Sanitation Access %", "Life Expectancy")
```

## Inferences

seems like Linear correlation

# Bivariate Statistics

## Covariance and Correlation Matrices {.smaller}

*Covariance* $\operatorname{cov}(x, y)$ is a measure of the joint variability of two random variables $x$, $y$.

*Correlation* is any relationship, causal or spurious, between two random variables $x$, $y$. *Pearson's correlation coefficient* $r$ estimates the linear correlation.

<details>

<summary>Formulae</summary>

$$
\begin{aligned}
\operatorname {cov} (x,y)={\frac {\sum _{i=1}^{n}(x_{i}-\bar{x})(y_{i}-\bar{y})}{n}}
&&
r_{x,y}= \frac{\operatorname{cov}(x,y)}{s_x s_x}
\end{aligned}
$$

</details>

::: columns
::: {.column width="48%"}
```{r echo=TRUE}
cov_mat = cov(d[, 2:4])

kable(cov_mat, digits=5)
```

$$A_{i,j} = \operatorname{cov}(x_i, x_j)$$
:::

::: {.column width="4%"}
:::

::: {.column width="48%"}
```{r echo=TRUE}
cor_mat = cor(d[, 2:4])

kable(cor_mat, digits=5)
```

$$A_{i,j} = r_{x_i, x_j}$$
:::
:::

## Other Correlation Coefficients

*Spearman's* $r_s$, and *Kendall's* $\tau$ are some other correlation coefficients besides *Pearson's* $r$

```{r echo=TRUE}
d_cor = data.frame(
  row.names = "Variable",
  Variable = c(
    "*Sanitation vs. ln(GDP)*",
    "*Life Exp. vs. ln(GDP)*",
    "*Life Exp. vs. Sanitation*"
  ),
  Pearson = c(
    cor(d$snt, d$lngdp, method="pearson"),
    cor(d$lfx, d$lngdp, method="pearson"),
    cor(d$lfx, d$snt, method="pearson")
  ),
  Spearman = c(
    cor(d$snt, d$lngdp, method="spearman"),
    cor(d$lfx, d$lngdp, method="spearman"),
    cor(d$lfx, d$snt, method="spearman")
  ),
  Kendall = c(
    cor(d$snt, d$lngdp, method="kendall"),
    cor(d$lfx, d$lngdp, method="kendall"),
    cor(d$lfx, d$snt, method="kendall")
  )
)

kable(
  d_cor,
  digit = 5,
  col.names = c(
    "*Pearson's* $r$",
    "*Spearman's* $r_s$",
    "*Kendall's* $\\tau$"
  )
)
```

## Inferences

Good linear correlation lets try to observe line of best fit.

# Regression

## Simple Linear Regression

*Simple Univariate Linear Regression* is a method for estimating the relationship $y_i=f(x_i)$ of a *response* variable $y$ with a *predictor* variable $x$, as a line that closely fits the $y$ vs. $x$ *scatter plot*.

$$
y_i = \hat{a} + \hat{b} x_i + e_i
$$

Where $\hat{a}$ is the *intercept*, $\hat{b}$ is the *slope*, and $e_i$ is the i<sup>th</sup> residual *error*. We aim to minimize $e_i$ for better fit.

## Ordinary Least Squares {.smaller}

*Ordinary Least squares method* reduces $e_i$ by minimizing *error sum of squares* $\sum{{e_i}^2}$.

*Coefficient of Determination* $R^2$ is the proportion of the variation in $y$ predictable by the model.

<details>

<summary>Formulae</summary>

$$
\begin{aligned}
\hat{b} = r\frac{s_y}{s_x} &&
\hat{a} = \bar{y} - \hat{b}\bar{x} &&
R^2 = 1 - \frac{\sum{{e_i}^2}}{\sum{(y-\bar{y}})^2}
\end{aligned}
$$

</details>

```{r echo=TRUE}
olssmry = function(
    d, x_map, y_map,
    x_lab=waiver(), y_lab=waiver(),
    title=waiver()
){
  model = lm(formula=y_map~x_map)
  smry = summary(model, signif.stars=TRUE)
  
  smryvec = c(
    as.numeric(model$coefficients["(Intercept)"]),
    as.numeric(model$coefficients["x_map"]),
    smry$r.squared
  )
  
  return(smryvec)
}

olstab = t(data.frame(
  SvG = olssmry(d, d$lngdp, d$snt),
  LvG = olssmry(d, d$lngdp, d$lfx),
  LvS = olssmry(d, d$snt, d$lfx)
))

row.names(olstab) = c(
  "*Sanitation vs. ln(GDP)*",
  "*Life Exp. vs. ln(GDP)*",
  "*Life Exp. vs. Sanitation*"
)

kable(
  olstab,
  digit = 5,
  col.names=c(
  "$\\hat{a}$",
  "$\\hat{b}$",
  "$R^2$"
  )
)
```

## Least Absolute Deviation

*Least absolute Deviation method* reduces $e_i$ by minimizing the *sum of absolute deviations* $\sum{|e_i|}$.

```{r echo=TRUE}
ladsmry = function(
    d, x_map, y_map,
    x_lab=waiver(), y_lab=waiver(),
    title=waiver()
){
  model = rq(formula=y_map~x_map)
  smry = summary(model)
  
  smryvec = c(
    as.numeric(model$coefficients[1]),
    as.numeric(model$coefficients[2])
  )
  
  return(smryvec)
}

olstab = t(data.frame(
  SvG = ladsmry(d, d$lngdp, d$snt),
  LvG = ladsmry(d, d$lngdp, d$lfx),
  LvS = ladsmry(d, d$snt, d$lfx)
))

row.names(olstab) = c(
  "*Sanitation vs. ln(GDP)*",
  "*Life Exp. vs. ln(GDP)*",
  "*Life Exp. vs. Sanitation*"
)

kable(
  olstab,
  digit = 5,
  col.names=c(
  "$\\hat{a}$",
  "$\\hat{b}$"
  )
)
```

# Line Fitting

Plotting the estimated *Linear Models* on the Scatter Plots.

```{r echo=TRUE}

linearplot = function(
    d, x_map, y_map,
    x_lab=waiver(), y_lab=waiver(),
    title=waiver()
){
  olsvec = round(olssmry(d, x_map, y_map), digit=5)
  ladvec = round(ladsmry(d, x_map, y_map), digit=5)
  capstr = TeX(paste("$y_i =", olsvec[1], "+", olsvec[2], "~x_i + e_i$", "\t\t",
                     "$y_i' =", ladvec[1], "+", ladvec[2], "~x_i + e_i'$"))
  
  plot1 = ggplot(d, mapping = aes(x = x_map, y = y_map))+
    geom_point(
      alpha=0.6
    )+
    mytheme+
    labs(
      x=x_lab,
      y=y_lab,
      title=title,
      caption=capstr,
      parse=TRUE
    )+
    geom_smooth(
      method="lm",
      formula=y~x,
      se=FALSE,
      aes(color = "Ordinary Least Squares")
    )+
    geom_smooth(
      method="rq",
      formula=y~x,
      se=FALSE,
      aes(color = "Least Absolute Deviation")
    )+
    labs(
      color="Linear Model"
    )+
    mycolor+
    theme(
      plot.caption = element_text(hjust=0.5, color="#504945")
    )
  
  return(plot1)
}
```

## Sanitation vs. GDP per Capita

```{r}
#| fig-align: center
linearplot(d, d$lngdp, d$snt, "log of GDP per capita", "Sanitation Access %")
```

## Life Expectancy vs. GDP per Capita

```{r}
#| fig-align: center
linearplot(d, d$lngdp, d$lfx, "log of GDP per capita", "Life Expectancy")
```

## Life Expectancy vs. Sanitation

```{r}
#| fig-align: center
linearplot(d, d$snt, d$lfx, "Sanitation Access %", "Life Expectancy")
```

## Inferences

# Partial Correlation {.smaller}

*Partial Correlation* is the relationship between two variables $x$, $y$ of interest, after removing effect of some other related variable $z$.

$$
\begin{aligned}
&x_i = \hat{a_x} + \hat{b_x} z_i + e_{x,i} &&
y_i = \hat{a_y} + \hat{b_y} z_i + e_{y,i}
\\
&\Rightarrow r_{x,y;z} = r_{e_{x}, e_{y}}
\end{aligned}
$$

```{r echo=TRUE}
partcor = pcor(d[, 2:4])$estimate

pcortab = data.frame(
  row.names = "Variable",
  Variable = c(
    "*Sanitation vs. ln(GDP)*",
    "*Life Exp. vs. ln(GDP)*",
    "*Life Exp. vs. Sanitation*"
  ),
  PCor = c(
    partcor[2, 1],
    partcor[3, 1],
    partcor[3, 2]
  )
)

kable(pcortab,
      col.names = c(
        "Partial Correlation"
      ))
```

## Inferences

# Conclusion

# Credits

-   Dr. Kiranmoy Das
-   [Gapminder](https://gapminder.org)
-   [Wikipedia](https://wikipedia.org)
-   [Statology](https://statology.org)
-   [Quarto](https://quarto.org)
-   [RStudio](https://posit.co/products/open-source/rstudio/)
